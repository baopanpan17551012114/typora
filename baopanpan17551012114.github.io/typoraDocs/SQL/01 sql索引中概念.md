**索引的作用**

\- 提高查询效率

\- 利用唯一性约束，保证数据唯一性

所以总的来说：**保证数据唯一性**  和  **优化查询效率**

**索引的副作用**

\- 增加I/O成本

\- 增加磁盘空间

\- 不合适的索引或索引过多，会降低增删改的效率

**索引的分类**

**1 存储结构**

\- BTREE：InnoDB & MyISAM

\- HASH：HEAP，NDB，InnoDB AHI

\- Fractal Tree：TokuDB

\- RTREE

\- FULLTEXT

**2 数据的存储方式**

\- 聚集索引：聚簇索引的顺序就是数据的物理存储顺序，索引与数据存放在同一个文件中。

\- 非聚集索引：非聚簇索引的顺序与数据的物理存储顺序不同，索引与数据存放在不同的文件。

 **3 应用层次**

\- 单列：主键索引、唯一索引、普通索引

\- 多列：复合索引



# sql索引

不给数据库加索引的话，多数情况下，它就真的是一行行找，效率极低；

MySQL的索引本质也是一张表的，建立索引也需要相应的空间；

**数据更新或者删除后，索引是否会更新，或者说什么时候更新？**



## 索引类型

- 单值索引：即一个索引只包含单个列。一个表可以有多个单列索引。
- 唯一索引：索引列的值必须唯一，但允许有空值。
- 复合索引：即一个索引包含多个列。

**建议**：建立复合索引，且一个表不要超过5个索引。



## 基本语法

- 创建（如果加上UNIQUE则创建唯一索引）：

  `CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));`

  CREATE UNIQUE INDEX uk_pid_goodsid ON alg_ec_recommend_cvr_for_ranking (pid, goodsid)

  或
  `ALTER mytable ADD [UNIQUE] INDEX[indexName] ON (columnname(length));`

  alter table alg_ec_recommend_sale_for_recall_pid_with_more_info add index sale_number_for_sort (`sale_number`);

- 删除：

  `DROP INDEX [indexName] ON mytable;`

- 查看：

  `SHOW INDEX FROM table\G`

  ## 建立索引的时机

  ##### 哪些情况需要创建索引

  - 主键自动建立唯一索引
  - 频繁作为查询条件的字段应该创建索引
  - 查询中与其他表关联的字段，外键关系建立索引
  - 频繁更新的字段**不适合**创建索引 — 因为每次更新不只更新记录还会更新索引
  - Where里**用不到**的字段的不创建索引
  - 单键/组合索引的选择问题 — 在高并发下倾向创建组合索引
  - 查询中排序的字段 — 排序字段若通过索引去访问将大大提高排序速度
  - 查询中统计或者分组字段

  ##### 哪些情况不需要创建索引

  - 表记录太少 — mysql300w左右就可以考虑建索引了

  - 经常增删改的表 — 因为索引要跟着更新

  - 数据重复且分布平均的表字段 — 可以用（该字段不同的数据的数量）/（该字段总的数据量），值越接近1，说明不怎么重复，越有建索引的价值。

    

  ## 表设计方面目前一致坚持和提倡的原则：

  - 单表数据量
    所有表都需要添加注释，单表数据量建议控制在 3000 万以内
  - 不保存大字段数据
    不在数据库中存储图片、文件等大数据
  - 表使用规范
    拆分大字段和访问频率低的字段，分离冷热数据
    单表字段数控制在 20 个以内
  - 索引规范
    1.单张表中索引数量不超过 5 个
    2.单个索引中的字段数不超过 5 个
    3.INNODB 主键推荐使用自增列，主键不应该被修改，字符串不应该做主键，
    如果不指定主键，INNODB 会使用唯一且非空值索引代替
    4.如果是复合索引，区分最大的字段放在索引前面
  - 字符集utf8mb4(偏生字，表情符)