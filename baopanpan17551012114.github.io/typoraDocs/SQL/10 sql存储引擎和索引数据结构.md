![image-20210721205437018](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210721205437018.png)

## **索引数据结构分为哪几种**

二叉树、红黑树、Hash表、B树（B和B+）；

## **Hash表**

什么是hash? hash是一种散列函数，通过将输入值映射为一个数值，如： hash(100) = 1,不同的hash算法，hash之后的值有可能是不同的。 

Hash表是以数据映射形式存在于mysql中的，那么hash表是如何产生的呢？ 当添加一条数据到表中的时候，首先会对主键进行hash，然后将这条数据存在的地址和hash值建立一个映射关系，当我们根据主键查找这条数据的时候，只需要将主键进行hash，得到hash值，最后根据hash值就可以直接定位到这条数据。所以hash算法只需要进行一次磁盘IO,查询速度是非常快的。

![img](https://pic4.zhimg.com/80/v2-39575cdcadc5263339bc0741e7792dc3_720w.jpg)

## **hash算法很快，为什么mysql 很少使用hash索引？**

在上面说过，hash算法，在查找数据的时候只用进行一次磁盘IO，查询速度非常快，但是为什么mysql不推荐使用呢？主要有以下几个原因 1.hash冲突（占比小，因为mysql的hash算法质量比较高，造成hash冲突的概率比较低） 2.无法进行范围查询（因为hash表里面存放的是hash值，不是数据本身，所以无法进行数据的比较，如果你确定你的表中只会用到精准查找的话，则可以使用hash结构的索引）



## B 树

B 树的英⽂是 Balance Tree，也就是平衡的多路 搜索树，它的⾼度远⼩于平衡⼆叉树的⾼度。在⽂件系统和数据库系统中的索引结构 经常采⽤ B 树来实现。

B 树的结构如下图所示：

![img](https://pic3.zhimg.com/80/v2-01876a113565ff86af877d69738ef932_720w.jpg)

------

## B+ 树

主要变动如述：

- 修改key与子树的组织逻辑，将索引访问都落到叶子节点
- 按顺序将叶子节点串起来（方便范围查询）



B+树基于 B 树做出了改进，主流的 DBMS 都⽀持 B+树的索引⽅式，⽐如 MySQL。B+树和 B 树的差异在于以下⼏点： 

1. 有 k 个孩⼦的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而B 树中， 孩⼦数量 = 关键字数+1。 
2. 非叶子节点的关键字也会同时存在在⼦节点中，并且是在⼦节点中所有关键字的 最⼤（或最⼩）。 
3. 非叶子节点仅⽤于索引，不保存数据记录，跟记录有关的信息都放在叶子节点 中。⽽ B 树中，非叶子节点既保存索引，也保存数据记录。 
4. 所有关键字都在叶子节点出现，叶子节点构成⼀个有序链表，⽽且叶子节点本⾝ 按照关键字的大小从小到大顺序链接。

下图就是⼀棵 B+树，阶数为 3，根节点中的关键字 1、18、35 分别是⼦节点（1， 8，14），（18，24，31）和（35，41，53）中的最⼩值。每⼀层⽗节点的关键字都会出现在下⼀层的⼦节点的关键字中，因此在叶⼦节点中包括了所有的关键字信息，并且每⼀个叶⼦节点都有⼀个指向下⼀个节点的指针，这样就形成了⼀个链表。



![img](https://pic1.zhimg.com/80/v2-161d0258eb28a6367d5e93d65aea7088_720w.jpg)

比如，我们想要查找关键字 16，B+ 树会⾃顶向下逐层进行查找： 

1、与根节点的关键字，（1，18，35）进⾏⽐较，16 在 1 和 18 之间，得到指针 P1（指 向磁盘块 2） 

2、 找到磁盘块 2，关键字为（1，8，14），因为 16 ⼤于 14，所以得到指针 P3（指向磁盘块 7） 

3、找到磁盘块 7，关键字为（14，16，17），然后我们找到了关键字 16，所以可以 找到关键字 16 所对应的数据。

B+树和 B 树有个根本的差异在于，B+树的中间节点并不直接存储数据。⾸先，B+树查询效率更稳定。因为 B+树每次只有访问到叶⼦节点才能找到对应的数据，⽽在 B 树中，⾮叶⼦节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了⾮叶⼦节点就可以找到关键字，⽽有时需要访问到叶⼦节点才能找到 关键字。 其次，B 树的查询效率更⾼，这是因为通常 B 树⽐ B 树更矮胖（阶数更⼤，深度 更低），查询所需要的磁盘 I/O 也会更少。同样的磁盘⻚⼤⼩，B 树可以存储更多 的节点关键字。 不仅是对单个关键字的查询上，在查询范围上，B 树的效率也⽐ B 树⾼。这是因为 所有关键字都出现在 B 树的叶⼦节点中，并通过有序链表进⾏了链接。⽽在 B 树中 则需要通过中序遍历才能完成查询范围的查找，效率要低很多。

## **mysql的b+ tree优化了什么？**

我们看下mysql中的B+树长什么样子的

![img](https://pic4.zhimg.com/80/v2-95370d1fd504fef37011edab57aa2d3f_720w.jpg)

1.增加了一个双向的指针 2.首尾节点也通过指针进行关联起来 主要目的是为了更加友好的支持索引内部的范围查找。如果不加双向链表指针，我们每次查找的时候，都要回到根节点查找，增加了磁盘IO，增加查询时间。

## **如何计算 B+ tree最大支持数据量**

在mysql中，可以使用`SHOW GLOBAL STATUS LIKE 'Innodb_page_size%'`指令查找到mysql对索引节点页面大小的设置，这个参数的大小决定了我们一次性能够从磁盘盘中load出多少索引数量。 在5.7版本中Innodb_page_size 默认设置为16384，也就是16k。 我们现在计算下myssql中，如果存储引擎为innodb的话，大概能支撑多少量级的数据？ 我们按照高度为3的树进行计算：

1.按照每个bigint数据类型的字段存储，每个非叶子索引节点最多需要8B 2.再加上每个索引节点后面连接的指针，指针在innodb中设置的大小为6B 3.两者加起来总共14B,所以一级节点总共能存储 16kB/14B = 1170个索引节点 4.二级节点都是从一级节点划分出来，也就是一级节点中的每个节点又能划分出1170个，所以二级节点和一级节点总共能存储1170*1170 = 1368900个 索引节点。 5.三级节点也就是叶子节点，叶子节点存储的是主键值+记录数据，记录数据最多为1K，这个时候主键值8B可以忽略不计了，所以每个叶子节点最多能存储16k/1k = 16条记录。 6.所以Innodb引擎结构的表中最多能支撑1170*1170*16 = 21902400 条数据，大概21亿，如果大于这个值，基本上都需要进行分库分表了，mysql建议B+树的深度最好小于3. ``





https://www.cnblogs.com/yufeng218/p/12465694.html

## 存储引擎

###  1、MyISAM存储引擎索引实现

MyISAM存储引擎的索引文件和数据文件是分离的（非聚集）；

MyISAM 存储引擎的一个表有3个文件： *.frm 文件存储的表的结构； *.MYD 文件存储表的数据； *.MYI 文件存储表中的索引数据；

**MYISAM 存储引擎的索引的叶子节点的data中存储的是索引所在行的磁盘指针； ---- 非聚集索引**

**MYISAM 存储引擎的主键索引 和 非主键索引的存储是差不多的，InnoDB 存储引擎的 主键索引 和 非主键索引存储是不一样的；**

###  2、InnoDB 存储引擎-索引实现

InnoDB存储引擎**索引文件和数据文件是合一的(聚集)**；

InnoDB 存储引擎的1个表有2个文件： *.frm 文件存储表的结构； *.ibd 文件存储的是索引和数据；

**InnoDB表的数据文件本身就是按 B+Tree 组织的一个索引结构文件；聚集索引叶子节点包含了完整的数据记录**；



**在Innodb中，聚簇索引默认就是主键索引。**

**在Innodb中，Mysql中的数据是按照主键的顺序来存放的。那么聚簇索引就是按照每张表的主键来构造一颗B+树，叶子节点存放的就是整张表的行数据。**

