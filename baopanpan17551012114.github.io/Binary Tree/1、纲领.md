### ⼆叉树解题的思维模式

分两类： 

**1、是否可以通过遍历⼀遍⼆叉树得到答案？如果可以，⽤⼀个 traverse 函数配合外部变量来实现，这叫 「遍历」的思维模式。** 

**2、是否可以定义⼀个递归函数，通过⼦问题（⼦树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利⽤这个函数的返回值，这叫「分解问题」的思维模式。** 

⽆论使⽤哪种思维模式，你都需要思考： 

如果单独抽出⼀个⼆叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不⽤你操⼼，递归函数会帮你在所有节点上执⾏相同的操作。

**⼆叉树题⽬的递归解法可以分两类思路，第⼀类是遍历⼀遍⼆叉树得出答案，第⼆类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核⼼框架 和 动态规划核⼼框架。**



### ⼆叉树的重要性 

举个例⼦，⽐如两个经典排序算法 快速排序 和 归并排序，对于它俩，你有什么理解？ 

如果你告诉我，快速排序就是个⼆叉树的前序遍历，归并排序就是个⼆叉树的后序遍历，那么我就知道你是个算法⾼⼿了。 



### 二叉树的前中后序

⼆叉树这种结构⽆⾮就是⼆叉链表，由于没办法简单改写成迭代形式，所以⼀般说⼆叉树的遍历框架都是指递归的形式。 只要是递归形式的遍历，都可以**有前序位置和后序位置**，分别在递归之前和递归之后。

**所谓前序位置，就是刚进⼊⼀个节点（元素）的时候，后序位置就是即将离开⼀个节点（元素）的时候**，那么进⼀步，你把代码写在不同位置，代码执⾏的时机也不同。

⽐如说，如果让你**倒序打印**⼀条单链表上所有节点的值，你怎么搞？ 实现⽅式当然有很多，但如果你对递归的理解⾜够透彻，可以利⽤**后序位置**来操作。本质上是利⽤递归的堆栈帮你实现了倒序遍历的效果。

教科书⾥只会问你前中后序遍历结果分别是什么，所以对于⼀个只上过⼤学数据结构课程的⼈来说，他⼤概以为⼆叉树的前中后序只不过对应三种顺序不同的 List<Integer> 列表。 

但是我想说，前中后序是遍历⼆叉树过程中处理每⼀个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List： 

- 前序位置的代码在刚刚进⼊⼀个⼆叉树节点的时候执⾏； 

- 后序位置的代码在将要离开⼀个⼆叉树节点的时候执⾏； 

- 中序位置的代码在⼀个⼆叉树节点左⼦树都遍历完，即将开始遍历右⼦树的时候执⾏。

**⼆叉树的所有问题，就是让你在前中后序位置注⼊巧妙的代码逻辑，去达到⾃⼰的⽬的，你只需要单独思考每⼀个节点应该做什么，其他的不⽤你管，抛给⼆叉树遍历框架，递归会在所有节点上做相同的操作。** 



综上，遇到⼀道⼆叉树的题⽬时的通⽤思考过程是： 

1、是否可以通过遍历⼀遍⼆叉树得到答案？如果可以，⽤⼀个 traverse 函数配合外部变量来实现。 

2、是否可以定义⼀个递归函数，通过⼦问题（⼦树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利⽤这个函数的返回值。 

3、⽆论使⽤哪⼀种思维模式，你都要明⽩⼆叉树的每⼀个节点需要做什么，需要在什么时候（前中后序）做。