# 最优⼦结构和 dp 数组的遍历⽅向怎么定？

1、到底什么才叫「最优⼦结构」，和动态规划什么关系。 

2、如何判断⼀个问题是动态规划问题，即如何看出是否存在重叠⼦问题。 

3、为什么经常看到将 dp 数组的⼤⼩设置为 n + 1 ⽽不是 n。 

4、为什么动态规划遍历 dp 数组的⽅式五花⼋⻔，有的正着遍历，有的倒着遍历，有的斜着遍历。

## ⼀、最优⼦结构详

最优⼦结构：可以从⼦问题的最优结果推出更⼤规模问题的最优结果。

想满⾜最优子结构，⼦问题之间必须互相独⽴。

让你算每个班的最优成绩就是⼦问题，你知道所有⼦问题的答案后，就可以借此推出全校学⽣的最优成绩这个规模更⼤的问题的答案。 

- 最优⼦结构并不是动态规划独有的⼀种性质，能求最值的问题⼤部分都具有这个性质；**但反过来，最优⼦结构性质作为动态规划问题的必要条件，⼀定是让你求最值的**，以后碰到那种恶⼼⼈的最值题，思路往动态规划想就对了，这就是套路。

- 找最优⼦结构的过程，其实就是证明状态转移⽅程正确性的过程，⽅程符合最优⼦结构就可以写暴⼒解了，写出暴⼒解就可以看出有没有重叠⼦问题了，有则优化，⽆则 OK。

## ⼆、如何⼀眼看出重叠⼦问题

写出了暴⼒解，很难判断这个解法是否存在重叠⼦问题，从⽽⽆法确定是否可以运⽤备忘录等⽅法去优化算法效率。

⾸先，最简单粗暴的⽅式就是画图，把递归树画出来，看看有没有重复的节点。

但稍加思考就可以知道，其实根本没必要画图，可以通过递归框架直接判断是否存在重叠⼦问题。 

```java
int dp(int[][] grid, int i, int j) {
 dp(grid, i - 1, j), // #1
 dp(grid, i, j - 1) // #2
}
```

可以看到 i, j 的值在不断减⼩，那么我问你⼀个问题：如果我想从状态 (i, j) 转移到 (i-1, j-1)，有⼏种路径？ 

显然有两种路径，可以是 (i, j) -> #1 -> #2 或者 (i, j) -> #2 -> #1，不⽌⼀种，说明 (i-1, j-1) 会被多次计算，所以⼀定存在重叠⼦问题。

## 三、dp 数组的⼤⼩设置 

**理论上，你怎么定义都可以，只要根据定义处理好 base case 就可以。**

你看 dp 函数的定义，dp(s1, i, s2, j) 计算 s1[0..i] 和 s2[0..j] 的编辑距离，那么 i, j 等于 -1时代表空串的 base case，所以函数开头处理了这两种特殊情况。 

再看 dp 数组，你当然也可以定义 dp[i][j] 存储 s1[0..i] 和 s2[0..j] 的编辑距离，但问题是 base case 怎么搞？索引怎么能是 -1 呢？ 

所以我们把 dp 数组初始化为 int[m+1][n+1]，让索引整体偏移⼀位，把索引 0 留出来作为 base case 表示空串，然后定义 dp[i+1][j+1] 存储 s1[0..i] 和 s2[0..j] 的编辑距离。

## 四、dp 数组的遍历⽅向

如果仔细观察的话可以发现其中的原因，你只要把住两点就⾏了： 

**1、遍历的过程中，所需的状态必须是已经计算出来的。** 

**2、遍历结束后，存储结果的那个位置必须已经被计算出来**

现在，你应该理解了这两个原则，主要就是看 base case 和最终结果的存储位置，保证遍历过程中使⽤的数据都是计算完毕的就⾏，有时候确实存在多种⽅法可以得到正确答案，可根据个⼈⼝味⾃⾏选择

## 动态规划通⽤技巧：数学归纳思想

1、明确 dp 数组的定义。这⼀步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 dp 数组的定义，运⽤数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，⼀旦这⼀步完成，整个题⽬基本就解决了。 

但如果⽆法完成这⼀步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是dp 数组存储的信息还不够，不⾜以推出下⼀步的答案，需要把 dp 数组扩⼤成⼆维数组甚⾄三维数组。