BFS 的核⼼思想应该不难理解的，就是把⼀些问题抽象成图，从⼀个点开始，向四周开始扩散。⼀般来说，我们写 BFS 算法都是⽤「队列」这种数据结构，每次将⼀个节点周围的所有节点加⼊队列。

BFS 相对 DFS 的最主要的区别是：**BFS** **找到的路径⼀定是最短的，但代价就是空间复杂度⽐** **DFS** **⼤很多**，

**问题的本质就是让你在⼀幅「图」中找到从起点** **start** **到终点** **target的最近距离，这个例⼦听起来很枯燥，但是** **BFS** **算法问题其实都是在⼲这个事⼉**，

框架：

```java
// 计算从起点 start 到终点 target 的最近距离 
int BFS(Node start, Node target) { 
  Queue<Node> q; // 核⼼数据结构 
  Set<Node> visited; // 避免⾛回头路 
  q.offer(start); // 将起点加⼊队列 
  visited.add(start); 
  int step = 0; // 记录扩散的步数 
  while (q not empty) { 
    int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ 
    for (int i = 0; i < sz; i++) { 
      Node cur = q.poll(); 
      /* 划重点：这⾥判断是否到达终点 */
      if (cur is target) 
        return step; 
      /* 将 cur 的相邻节点加⼊队列 */ 
      for (Node x : cur.adj()) 
        if (x not in visited) { 
          q.offer(x); visited.add(x); 
        } 
    }
    /* 划重点：更新步数在这⾥ */ 
    step++; 
  } 
}
```

BFS 可以找到最短距离，但是空间复杂度⾼，⽽ DFS 的空间复杂度较低。

由此观之，BFS 还是有代价的，⼀般来说在找最短路径的时候使⽤ BFS，其他时候还是 DFS 使⽤得多⼀些（主要是递归代码好写）。



**双向** **BFS** **优化** 

BFS 算法还有⼀种稍微⾼级⼀点的优化思路：**双向** **BFS**，可以进⼀步提⾼算法的效率。 

**传统的** **BFS** **框架就是从起点开始向四周扩散，遇到终点时停⽌**

**⽽双向** **BFS** **则是从起点和终点同时开始扩散，当两边有交集的时候停⽌**

**不过，双向** **BFS** **也有局限，因为你必须知道终点在哪⾥**。

⽐如我们刚才讨论的⼆叉树最⼩⾼度的问题，⼀开始根本就不知道终点在哪⾥，也就⽆法使⽤双向 BFS；但是第⼆个密码锁的问题，是可以使⽤双向 BFS 算法来提⾼效率的

不过话说回来，**⽆论传统** **BFS还是双向BFS，⽆论做不做优化，从Big O衡量标准来看，时间复杂度都是⼀样的**，只能说双向 BFS 是⼀种 trick，算法运⾏的速度会相对快⼀点，掌握不掌握其实都⽆所谓。最关键的是把BFS 通⽤框架记下来，反正所有 BFS 算法都可以⽤它套出解法